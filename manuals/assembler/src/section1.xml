<?xml version="1.0"?>
<chapter xmlns="http://docbook.org/ns/docbook">
  <title>Text Editor</title>
  <section>
    <title>Introduction to the Macro Text Editor</title>
    <para>
The Macro Text Editor is a powerful and easy to use text preparation
system. It is commonly used to create source programs or other kinds of
text files used within the OS-9 system. The editor has many features
that make editing faster and more convenient. For example, most commands
involve only one or two keystrokes.
</para>
    <para>
The <quote>Macro</quote> part of the editor's name refers to the its macro
facility which allows you to create new personalized commands or complex
commands for special purposes from the basic built-in command set.
</para>
    <para>
Because the editor has its own variables and loops it can be used as
a kind of text-oriented programming language, which is especially useful
for large software conversion problems.
</para>
    <para>
The editor can also edit several different files at the same time,
and even copy text from one file to another.
</para>
  </section>
  <section>
    <title>Getting Started</title>
    <para>
The editor is kept in a file called <quote>edit</quote>, which should be present
in your system's CMDS (execution) directory. To run the editor type:
<screen>
OS9: edit <keycap>RETURN</keycap>
</screen>

The editor should load and start. When it prints the <quote>E: </quote> prompt, it is ready to accept a command.
The first command to learn is how to quit editing (return to OS-9). To quit, type a <quote>Q</quote> followed by a carriage
return as follows:

<screen>
E: q <keycap>RETURN</keycap>
</screen>
</para>
    <para>
Now that you can get in and out of the editor, it is time to learn a
little about some basic edit commands which are discussed in the sections
on Display, Edit Pointer Manipulation, and Insertion/Deletion. After
you have mastered the basic commands, you should move on to the more
advanced commands. Good Luck!
</para>
  </section>
  <section>
    <title>The Edit Command Line</title>
    <para>
When you run EDIT, you can optionally specify initial input and
output file(s). Although you may open additional files after the editor
has been started, there are several commands which treat the initial
files as special cases because it is assumed that these files
(if specified) are the main working files.
</para>
    <para>
You may also want to use the OS-9 shell <quote>#</quote> memory size option to
give the editor a bigger memory space, which will let you edit bigger
sections of a file at once. If you don't, the default size is 4K bytes.
For example:

<screen>
OS9: EDIT myfile #24k <keycap>RETURN</keycap>
</screen>
</para>
    <para>
Some of the different forms of the edit command line are illustrated
below. The name <quote>newfile</quote> refers to the name of a new file you wish to
create. The name <quote>oldfile</quote> refers to the name of an existing file you
wish the editor to use.
</para>
    <synopsis>
EDIT
</synopsis>
    <para>
There will be no initial input or output files. Text file operations may
be performed by opening files after the editor has started running.
</para>
    <synopsis>
EDIT newfile
</synopsis>
    <para>
The editor will create a new file called <quote>newfile</quote> which will be the
initial output file.V There will be no initial input file. However, read
operations may be performed by opening files after the editor has started
running.
</para>
    <synopsis>
EDIT oldfile
</synopsis>
    <para>
The initial input file is <quote>oldfile</quote>. The editor will create a new
temporary file called <quote>SCRATCH</quote> that will be the initial output file.
when the edit session is done, <quote>oldfile</quote> will be deleted, and then
<quote>SCRATCH</quote> will be renamed to the name <quote>oldfile</quote> to give the appearance of
<quote>oldfile</quote> simply being updated. Note: The two OS-9 utilities <quote><command>DEL</command></quote> and
<quote><command>RENAME</command></quote> must be present on your system if you wish to use this method to
start the editor.
</para>
    <synopsis>
EDIT oldfile newfile
</synopsis>
    <para>
The initial input file is <quote>oldfile</quote>. The editor will create a new file
called <quote>newfile</quote>, which will be the initial output file.
</para>
  </section>
  <section>
    <title>Edit Buffers</title>
    <para>
The text being edited is stored in a memory space called an <quote>edit buffer</quote>.
Edit buffers may be thought of as scratch pads used for saving
the text to be manipulated by the editor.
</para>
    <para>
There is always at least one edit buffer, but you can create several
at the same time if you wish. The buffer currently being used is
called the <quote>primary buffer</quote>, and the last most recently used buffer is
called the <quote>secondary buffer</quote>. Normally, the primary buffer will simply
be referred to as the <quote>buffer</quote> or <quote>edit buffer</quote> for short, except where
it is explicitly called the primary buffer. The secondary buffer is
important only when you wish to use a command that involves moving text
from one buffer to another.
</para>
  </section>
  <section>
    <title>Edit Pointers</title>
    <para>
The macro text editor uses what is called an <quote>edit pointer</quote> as a
place holder to remember your current position in the text buffer. Many
commands operate on the text at the current edit pointer position. This
is similar to a person using his finger as a place holder when reading a
newspaper. Certain commands may be used to reposition the edit pointer,
or show the text that it points to, etc. Each buffer has its own edit
pointer to allow you to move from buffer to buffer without losing your
place in any of them.
</para>
  </section>
  <section>
    <title>Entering Commands</title>
    <para>
Whenever the editor prints the <quote>E:</quote> prompt, it is ready for you to
enter a command line. You can type one or more edit commands on a single
line followed by <keycap>RETURN</keycap>. Some edit commands have <quote>parameters</quote> which are
values used by the command.
</para>
    <para>
Multiple commands on a single line can be optionally separated by
spaces, but you should not start a command line with a space because the
space character is itself a command (insert line).
</para>
    <para>
Many of the commands are single characters designed for rapid entry,
for example <quote>L</quote> and <quote>D</quote>. Some other command are function keys such as
<keycap>SPACE</keycap> and <keycap>RETURN</keycap> which only apply
if they are the first character of the line.
Yet other commands are <quote>built-in macros</quote>, which are
descriptive names starting with a <quote>.</quote>, such as <quote>.size</quote> and <quote>.shell</quote>. In
general, all three kinds work the same way despite the differences in form.
</para>
    <para>
If you make a mistake while typing, it may be corrected before the
mistake reaches the editor by using the backspace key, or by deleting the
entire line using the
<keycombo action="simul"><keycap>CONTROL</keycap><keycap>X</keycap></keycombo>
key (of course editor commands can also be used to fix mistakes!).
The usual OS-9 control characters work in the
editor, see the <citetitle pubwork="book">OS-9 Operating System User's Guide</citetitle>.
A summary is given below:
</para>
    <variablelist termlength="11">
      <varlistentry>
        <term>
          <keycombo action="simul">
            <keycap>CONTROL</keycap>
            <keycap>A</keycap>
          </keycombo>
        </term>
        <listitem>
          <para>
Repeat previous input line.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <keycombo action="simul">
            <keycap>CONTROL</keycap>
            <keycap>C</keycap>
          </keycombo>
        </term>
        <listitem>
          <para>
Interrupt whatever the editor is doing and return to command entry mode.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <keycombo action="simul">
            <keycap>CONTROL</keycap>
            <keycap>D</keycap>
          </keycombo>
        </term>
        <listitem>
          <para>
Redisplay present input line.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <keycombo action="simul">
            <keycap>CONTROL</keycap>
            <keycap>H</keycap>
          </keycombo>
        </term>
        <listitem>
          <para>
Backspace.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <keycombo action="simul">
            <keycap>CONTROL</keycap>
            <keycap>Q</keycap>
          </keycombo>
        </term>
        <listitem>
          <para>
Same as <keycombo action="simul"><keycap>CONTROL</keycap><keycap>C</keycap></keycombo>.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <keycombo action="simul">
            <keycap>CONTROL</keycap>
            <keycap>W</keycap>
          </keycombo>
        </term>
        <listitem>
          <para>
This control key will temporarily halt output to your terminal so that
you can read the screen before the data scrolls off.
Output is resumed when you type any other key.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <keycombo action="simul">
            <keycap>CONTROL</keycap>
            <keycap>X</keycap>
          </keycombo>
        </term>
        <listitem>
          <para>
Line delete.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <keycap>ESCAPE</keycap>
        </term>
        <listitem>
          <para>
Quit editor - same as <quote>Q</quote> command.
</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Parameters</title>
    <para>
Many of the editor's commands allow you to specify some value which
may represent such things as the number of times to repeat a command or a
phrase you wish to find, etc. There are two types of edit parameters,
<quote>numeric</quote> and <quote>string</quote>.
</para>
    <section>
      <title>Numeric Parameters</title>
      <para>
Numeric parameters are used when you wish to specify an amount, such
as the number of times to repeat a command or the number of text lines
that a command is be applied. The four methods in which a numeric
parameter may be specified are:
</para>
      <orderedlist>
        <listitem>
          <para>
The parameter can be omitted. In this case, a value of 1 is assumed.
The example below lists one line:
</para>
      <simplelist type="vert">
<member>L</member>
</simplelist>
        </listitem>
        <listitem>
          <para>
The parameter can be a constant number from 0 to 65535. The example
below shows the <quote>L</quote> (list lines) command with a parameter of <quote>10</quote>.
</para>
      <simplelist type="vert">
<member>L10</member>
</simplelist>
        </listitem>
        <listitem>
          <para>
The parameter can be <quote>*</quote> which means repeat the command as many times
as possible. The example below means <quote>list all lines</quote>.
</para>
      <simplelist type="vert">
<member>L*</member>
</simplelist>
        </listitem>
        <listitem>
          <para>
The parameter can be a numeric variable, which is a <quote>#</quote> followed by
the letters A-Z, to be used in conjunction with macros and is explained
in detail in the <quote>Edit Macro</quote> section.
</para>
        </listitem>
      </orderedlist>
    </section>
    <section>
      <title>String Parameters</title>
      <para>
Strings are used to specify a single character, word, phrase, or any
other arbitrary group of characters. There are two methods which You may
use to specify strings.
</para>
      <para>
The first method is to enclose the text between a pair of
<quote>delimiter</quote> characters. The delimiters are not part of the text. Any
characters can be used for delimiters, but punctuation characters chosen
so they are not included in the actual text are most commonly used. For
example, to tell the editor to search for the phrase <quote>fast code</quote> the
following command is used:
<synopsis>
S/fast code/
</synopsis>
</para>
      <para>
Unlike commands, a distinction is always made between upper case and
lower case strings. The example on the previous page would <emphasis>not</emphasis> find
<quote>FAST CODE</quote>.
</para>
    </section>
    <section>
      <title>Multiple Parameters</title>
      <para>
When a command requires two to more parameters, they are given in
the correct order immediately following the command name.
You do not have to type spaces or other characters between the parameters.
For example, the command to search for the next two occurrences of the phrase
<quote>compiler</quote> is:
</para>
      <synopsis>
S2/compiler/
</synopsis>
      <para>
If two string parameters are required by a command, three delimiters
are used: one at the beginning, one between the first string and the
second, and one at the end of the second string. For example, the
command to change the phrase <quote>my cat</quote> to <quote>my dog</quote> is:
</para>
      <synopsis>
C,my cat,my dog,
</synopsis>
      <para>
The second method uses <quote>string variables</quote>, which consist of a <quote>$</quote>
followed by a variable name of A-Z. These are most commonly used in
macros and are discussed in detail in the <quote>Edit Macro</quote> section.
</para>
    </section>
  </section>
  <section>
    <title>Syntax Notation</title>
    <para>
This manual uses syntax descriptions to help you understand how to
enter each command. They describe what you should enter and the order
that you should do it in. The first thing in a syntax description is the
command name. The name should be typed in exactly as given (except lower
case and upper case command names are interchangeable).
</para>
    <para>
The command name is followed by the type of parameters that the
command expects. Each of them should be entered as described in the
section on parameters. The syntax descriptions for each command use the
following definitions:
</para>
    <informaltable frame="none" colsep="0" rowsep="0">
      <tgroup cols="2">
        <colspec colwidth="1.7in"/>
        <colspec colwidth="4.0in"/>
        <tbody>
          <row>
            <entry><replaceable>n</replaceable></entry>
            <entry>numeric parameter</entry>
          </row>
          <row>
            <entry><replaceable>str</replaceable></entry>
            <entry>string parameter</entry>
          </row>
          <row>
            <entry>
              <keycap>SPACE</keycap>
            </entry>
            <entry>space character</entry>
          </row>
          <row>
            <entry>
              <keycap>RETURN</keycap>
            </entry>
            <entry>carriage return or <quote>enter</quote> key</entry>
          </row>
          <row>
            <entry><replaceable>text</replaceable></entry>
            <entry>one or more characters terminated by a <keycap>RETURN</keycap></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
  <section>
    <title>Basic Commands</title>
    <para>
This section describes the basic commands used to manipulate text
and control the editor. If you plan to only occasionally use Edit with
simple single-buffer editing, these command are all you need to know.
</para>
    <para>
For basic editing, you need only learn the commands listed below,
This editor is actually a proper superset of the Basic09 built-in editor,
so if you know Basic09; you already know how to use Edit effectively!
</para>
    <informaltable frame="none" colsep="0" rowsep="0">
      <tgroup cols="2">
        <colspec colwidth="1.0in"/>
        <tbody>
          <row>
            <entry>
              <keycap>+</keycap>
            </entry>
            <entry>Move Forward Line(s)</entry>
          </row>
          <row>
            <entry>
              <keycap>-</keycap>
            </entry>
            <entry>Move Backward Line(s)</entry>
          </row>
          <row>
            <entry>
              <keycap>SPACE</keycap>
            </entry>
            <entry>Insert Line</entry>
          </row>
          <row>
            <entry>
              <keycap>RETURN</keycap>
            </entry>
            <entry>Move Forward One Line And Display</entry>
          </row>
          <row>
            <entry>
              <keycap>C</keycap>
            </entry>
            <entry>Change String</entry>
          </row>
          <row>
            <entry>
              <keycap>L</keycap>
            </entry>
            <entry>List Line(s)</entry>
          </row>
          <row>
            <entry>
              <keycap>S</keycap>
            </entry>
            <entry>Search For String</entry>
          </row>
          <row>
            <entry>
              <keycap>Q</keycap>
            </entry>
            <entry>Quit Editing</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
You will notice that some commands work on entire lines (such as <quote>+</quote>),
and others work on characters within lines (such as <quote>&gt;</quote>). We also
recommend that beginners master line-oriented commands before moving on
to character-oriented commands.
</para>
    <section>
      <title>Change String</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para><literallayout>C <replaceable>n</replaceable> <replaceable>str1</replaceable> <replaceable>str2</replaceable>
.CHANGE <replaceable>n</replaceable> <replaceable>str1</replaceable> <replaceable>str2</replaceable></literallayout></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Change the next <replaceable>n</replaceable> occurrence of <replaceable>str1</replaceable> to <replaceable>str2</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command is used to change the next <replaceable>n</replaceable> occurrences of <quote><replaceable>str1</replaceable></quote> to
<quote><replaceable>str2</replaceable></quote>. Starting at the current edit pointer position; wherever <quote><replaceable>str1</replaceable></quote>
is found, it is changed to <quote><replaceable>str2</replaceable></quote>, and then the updated line is
displayed. Changes continue until no more occurrences of <quote><replaceable>str1</replaceable></quote> are found
or until the count <quote><replaceable>n</replaceable></quote> is reached, whichever occurs first.
</para>
      <para>
The <quote>C</quote> command leaves the edit pointer positioned at pointing to the
beginning of the last line changed. The <quote>.CHANGE</quote> built-in macro will
leave the edit pointer positioned just past the modified string. If
<quote><replaceable>str1</replaceable></quote> is not found, the edit pointer will not be affected. Some typical
examples of its use are:
</para>
      <simplelist type="horiz" columns="2">
        <member>C/this/that/</member>
        <member>.CHANGE/this/that/</member>
        <member>C2/in/out/</member>
        <member>.CHANGE 2 /in/out/</member>
        <member>C*! seek and find ! seek and found !</member>
      </simplelist>
<para>
The first example changes the next occurrence of <quote>this</quote> to <quote>that</quote>. The
second example changes the next two occurrence of <quote>in</quote> to <quote>out</quote>. The last
example changes all occurrences of <quote> seek and find </quote> to <quote> seek and found </quote>
that are between the edit pointer and end of text.
</para>
    </section>
    <section>
      <title>Delete Characters</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>K <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Delete (Kill) <replaceable>n</replaceable> characters.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command is used to erase <replaceable>n</replaceable> characters starting at the current edit
position; all deleted characters are displayed. Some examples are:
</para>
      <simplelist type="horiz" columns="3">
        <member>K</member>
        <member>K4</member>
      </simplelist>
      <para>
The first command deletes the character at the current edit position.
The second command deletes the character at the current edit position and
the next three characters.
</para>
    </section>
    <section>
      <title>Delete Lines</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>D <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Delete <replaceable>n</replaceable> lines.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>
      <para>
This command is used to delete (erase) <replaceable>n</replaceable> entire lines of text starting
with the current line, regardless of the edit pointer position in the
line. The deleted lines are displayed. Some examples are:
</para>
      <simplelist type="horiz" columns="3">
        <member>D</member>
        <member>D4</member>
        <member>D*</member>
      </simplelist>
      <para>
The first example deletes the current line and displays it. The second
example deletes the current line and the next three lines. The last
example deletes all the lines from the current line to the end of_the
edit buffer.
</para>
    </section>
    <section>
      <title>Extend Lines</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>E <replaceable>n</replaceable> <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Extend <replaceable>n</replaceable> lines with string.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command is used to extend (add to the end of) <replaceable>n</replaceable> lines with the
string given. After each line is extended, the line is displayed and the
edit pointer is moved past it. Below are some examples of how it may be used:
</para>
      <simplelist type="horiz" columns="3">
        <member>E/this is a comment/</member>
        <member>E3/XX/</member>
      </simplelist>
      <para>
The first example would add the string <quote>this is a comment</quote> to the end of
the current line and move the edit pointer to the next line. The second
example would add the string <quote>XX</quote> to the end of the current line and the
next two lines; the edit pointer would be moved past these lines.
</para>
    </section>
    <section>
      <title>Unextend Line</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>U</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Unextend (truncate) line</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command is used to unextend (truncate) a line at the current edit
position. The characters in the line from the current edit pointer
position to the end of the line are chopped off. The <quote>&gt;</quote> or <quote>&lt;</quote> commands
(see page 1-14) are usually used to position the pointer prior to use of
this command. For example:
</para>
      <simplelist type="horiz" columns="3">
        <member>U</member>
      </simplelist>
    </section>
    <section>
      <title>Insert Line</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para><keycap>SPACE</keycap> <replaceable>text</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Insert the line of text before edit position</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command is used to insert complete text lines. The lines are
inserted before the current edit position, and the edit pointer will be
positioned following the newly entered line. Therefore, many lines can
be automatically entered in order. The new lines will be inserted <emphasis>before</emphasis>
the line pointed to by the edit pointer prior to entry of the new lines.
For example:
<screen>
E: <keycap>SPACE</keycap>this is line one. <keycap>RETURN</keycap>
E: <keycap>SPACE</keycap>this is line two. <keycap>RETURN</keycap>
E: <keycap>SPACE</keycap>this is line three. <keycap>RETURN</keycap>
E: ^ <keycap>RETURN</keycap>
E: L* <keycap>RETURN</keycap>
This is line one.
This is line two.
This is line three.
E:
</screen>
</para>
    </section>
    <section>
      <title>Insert String</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>I <replaceable>n</replaceable> <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Insert a line containing <replaceable>n</replaceable> copies of <replaceable>str</replaceable> string</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command is used to insert a line made up of <replaceable>n</replaceable> copies of the string,
which is inserted before the edit pointer. Then the edit pointer is not
changed. For example, if you wanted to insert a line containing eighty
asterisks you would enter the following command:
<screen>
I80/*/
</screen>
Note that this command always inserts a [RETURN] after the text. While
this command is very similar to the [SPACE] (insert line) command, it is
provided because the [SPACE] command cannot be used within macros.

</para>
    </section>
    <section>
      <title>List Following Lines</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>L <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>List the next <replaceable>n</replaceable> lines of text</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command displays <replaceable>n</replaceable> lines of text starting at the current edit
position. The edit position is not changed. For example, the following
command will cause the editor to display the current line of text:
<synopsis>
L
</synopsis>
If you wish to display the three lines, enter the command line given
below:
<synopsis>
L3
</synopsis>
If the edit pointer is not at the beginning of the first line, only that
part of the line from the edit pointer to end of line will be displayed.
To see all the text from the current edit position to the end of the
buffer, use an asterisk for the value as in the following command line:
<synopsis>
L*
</synopsis>
The <quote>L</quote> command is not affected by <quote>verify</quote> mode;

</para>
    </section>
    <section>
      <title>List Previous Lines</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>X <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Display previous lines of text</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command is identical to the L command except it list lines <emphasis>before</emphasis>
the current edit pointer position.
</para>
    </section>
    <section>
      <title>Memory Size Adjust</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>M <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Adjust the workspace size to <replaceable>n</replaceable> bytes.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Directive to Editor</para>
        </listitem>
      </varlistentry>
   </variablelist>
      <para>
This command is used to adjust the workspace size (total amount of memory
available for buffers and macros). If the workspace becomes full and the
editor prevents you from entering more text, you may overcome the problem
by increasing the workspace size. If you will not be using a large
portion of the available workspace, you may wish to decrease the
workspace size so that other OS-9 programs may use the memory that you
free. Below are some examples of how the <quote>M</quote> command is used:
</para>
      <simplelist type="horiz" columns="3">
        <member>M5000</member>
        <member>M10000</member>
      </simplelist>
      <para>
The first example sets the workspace size to 5000 bytes. The second
example sets the workspace size to 10000 bytes.
</para>
      <para>
Before using the <quote>Q</quote> command to quit editing, you may want to make the
workspace size larger to decrease the amount of time needed to copy the
input file to the output file allowing the editor to read and write a
larger portion of the file at one time. Note that memory is allocated in
256 byte pages. For the <quote>M</quote> command to have any effect, the desired
workspace size must differ from the current size by at least 256 bytes.
The <quote>M</quote> command will not allow you to return any part of the workspace
which is being used for buffers or macros.
</para>
    </section>
    <section>
      <title>Memory Size Display</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.SIZE</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Display workspace size.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Directive to Editor</para>
        </listitem>
      </varlistentry>
   </variablelist>
      <para>
This command is used to display the size of the workspace and the amount
that has been used, An example of how this command would be used is:
<screen>
E: .SIZE <keycap>RETURN</keycap>
  521 15328
</screen>
in the example above, the numbers that are printed below the <quote>.SIZE</quote>
command are <quote>521</quote> which is the amount of the workspace that has been used
for buffers and macros, <quote>15328</quote> is the total amount of memory available
in the workspace.
</para>
    </section>
    <section>
      <title>Move Characters Backward</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>&lt; <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Move backwards <replaceable>n</replaceable> characters.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command is used to move the edit pointer backwards (toward the
beginning of the text) <replaceable>n</replaceable> characters. It is typically used when moving
the edit pointer to some position in a line other than the first
character. Here are examples:
      <simplelist type="horiz" columns="3">
<member>&lt;</member>
<member>&lt;10</member>
</simplelist>
The first command line moves the edit pointer back one character. The
second command line moves the edit pointer back ten characters.

</para>
    </section>
    <section>
      <title>Move Characters Forward</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>&gt; <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Move forward <replaceable>n</replaceable> characters.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command is used to move the edit pointer forward (toward the end of
the text) <replaceable>n</replaceable> characters. It is typically used to move the edit pointer to
some position in the line other than the first character. Here are
examples:

      <simplelist type="horiz" columns="3">
<member>&gt;</member>
<member>&gt;25</member>
<member>&gt;*</member>
</simplelist>
The first command line moves the edit pointer forward (to the right) one
character. The second command line moves the edit pointer forward twenty
five characters. The last command line move the edit pointer to the end
of the buffer.
</para>
    </section>
    <section>
      <title>Move To End Of Text</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>/</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Move to end of text.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line- or Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command moves the edit pointer past the last character of the last
line in the buffer. Note that -* is identical in function to ^.
</para>
    </section>
    <section>
      <title>Move To Next Line And Display</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para><keycap>RETURN</keycap></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Move to next line and show it.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command moves the edit pointer to the beginning of the next line and
displays it. Note that the only character you should type to enter this
command is the <keycap>RETURN</keycap>-key. This command is after used to step through
the text one line at a time. For example:

<screen>
E:L3 <keycap>RETURN</keycap>        <lineannotation>list next three lines</lineannotation>
  This is line 1
  This is line 2
  This is line 3
E:<keycap>RETURN</keycap>
  This is line 2
E:<keycap>RETURN</keycap>
  This is line 3
</screen>

</para>
    </section>
    <section>
      <title>Move To Start Of Text</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>^</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
            <para>Move to beginning of text.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line and Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>
      <para>
This command moves the edit pointer to the beginning (top) character of
the first line in the edit buffer.
</para>
    </section>
    <section>
      <title>Move Lines Backwards</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>- <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
            <para><literallayout>If <replaceable>n</replaceable> =&gt; 1, go backward <replaceable>n</replaceable> lines and display the line.
If <replaceable>n</replaceable> = 0, go to the beginning of the line.</literallayout></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>
      <para>
The <quote>-</quote> command has two uses. If a number of one or more is given,
the edit pointer is moved backward that number of lines, and the new line
pointed to will be displayed. For example, the following command will
move the edit pointer backward 5 lines:
<synopsis>
-5
</synopsis>
If the <quote>-</quote> command is given with a number of zero, it moves the edit
pointer past to the first character of the current line. This can be
useful when you wish to repeat a command within the current line.
For example:
<synopsis>
-0
</synopsis>

</para>
    </section>
    <section>
      <title>Move Lines Forward</title>
   <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>+ <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
            <para><literallayout>If <replaceable>n</replaceable> =&gt; 1, go forward <replaceable>n</replaceable> lines and display the line.
If <replaceable>n</replaceable> = 0, go to the end of the line.</literallayout></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
The <quote>+</quote> command has two uses. If a number of one or more is given, the
edit pointer is moved forward that number of lines, and the new line
pointed to will be displayed. For example, the following command will
move the edit pointer forward 5 lines:
<synopsis>
+5
</synopsis>
If the <quote>+</quote> command is given with a number of zero, it moves the edit
pointer past to the last character of the current line. This can be
useful when you wish to append text to the current line. For example:
<synopsis>
+0
</synopsis>
Also note that <quote>+*</quote> is identical in function to <quote>/</quote>.
</para>
    </section>
    <section>
      <title>Quit Editor</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>Q</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Quit Edit Program</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Directive to Editor</para>
        </listitem>
      </varlistentry>
   </variablelist>

   <para>
This command is used to quit editing and return to the OS-9 Shell (or the
program that called Edit). For example:
<synopsis>
Q
</synopsis>
If input and/or output file(s) were specified on the OS-9 command line
when you started the editor, the text in buffer number one would be
written to the initial output file, then the remainder of the initial
input file will be copied to the output file. After the text has been
copied, the editor will be terminated and control returned to the Shell.
</para>
    </section>
    <section>
      <title>Search For String</title>
      
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>S <replaceable>n</replaceable> <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Line-Oriented</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.SEARCH <replaceable>n</replaceable> <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Character-Oriented</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Search for the next <replaceable>n</replaceable> occurrence of <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command is used to search for the next <replaceable>n</replaceable> occurrences of the string
specified, starting at the current edit pointer position. When a line
containing the string is found, the line is displayed.
</para>
      <para>
If the string is found, the edit pointer will be positioned at the
beginning of the last line in which the string was found. If no
occurrence of the string was found, the edit pointer position will be
unchanged.
</para>
      <para>
The <quote>.SEARCH</quote> built-in macro is similar to <quote>S</quote> except that it leaves the
edit pointer just past the occurrence of the string. Some typical
examples of its use are:
</para>
      <simplelist type="horiz" columns="2">
        <member>S/my string/</member>
        <member>.SEARCH/my string/</member>
        <member>S3"strung out"</member>
        <member>.SEARCH 3"strung out"</member>
        <member>S*/seek and find/</member>
        <member>.SEARCH*/seek and find/</member>
      </simplelist>
<para>
The first example searches for the next occurrence of <quote>my string</quote>. The
second example searches for the next three occurrence of <quote>strung out</quote>.
The last example searches for all occurrence of <quote>seek and find</quote> that are
between the edit pointer and the end of text.
</para>
    </section>
    <section>
      <title>Set Anchor Column</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>A <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
            <para>Set the SEARCH/CHANGE anchor to column number <replaceable>n</replaceable>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command is used to set the SEARCH/CHANGE anchor to column number <replaceable>n</replaceable>.
After the anchor has been set, the <quote>S</quote> and <quote>C</quote> commands will find a
string only if it begins in column number <replaceable>n</replaceable>.
For example, if you want to find a string that you know begins in column number one (such as an
assembly language label), but don't want to find it if it begins in any
other column, you should set the anchor to column one before using the
search command to find it to allow you to skip any occurrence of the
string that do not start in column one. Some typical examples of its use are:
</para>
      <simplelist type="horiz" columns="3">
        <member>A</member>
        <member>A50</member>
      </simplelist>
<para>
The first example would cause SEARCH/CHANGE to find a string only if it
began in column number one. The second example would cause SEARCH/CHANGE
to find a string only if it began in column number fifty.
</para>
      <para>
To return to the normal mode of searching so that a string may be found
regardless of the column that it begins in, the anchor should be set to
zero. For example:
<synopsis>
A0
</synopsis>
If you use the <quote>A</quote> command to set the anchor, this remains in effect only
for the Current command line. After the command line is executed the
anchor will automatically return to its normal value of zero.
</para>
    </section>
    <section>
      <title>Shell Command</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.SHELL <replaceable>text</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
          <para>Call the OS-9 SHELL to execute the text line.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Directive to Editor</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command allows you to use any of the OS-9 commands from within the
editor. The remainder of the command line following the <quote>.SHELL</quote> command
is passed to the OS-9 shell for execution. Some examples of how this
command may be used are:
<screen>
E: .SHELL dir /D1 <keycap>RETURN</keycap>

E: .SHELL asm prog.src l o=prog &gt;/p&amp; <keycap>RETURN</keycap>
</screen>
Notice that the second example starts the assembler as a background task.
</para>
    </section>
    <section>
      <title>Tab</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>T <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
            <para>Tab to character position <replaceable>n</replaceable>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Character-Oriented</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command is used to tab (move the edit pointer) to the character
position <quote><replaceable>n</replaceable></quote> of the current line. If <quote><replaceable>n</replaceable></quote> exceeds the line length, the
line will be extended with spaces. Some examples of usage are:
      <simplelist type="horiz" columns="3">
<member>T</member>
<member>T5</member>
<member></member>
</simplelist>
The first example would move the edit pointer to the first column of the
current line. The second example would move the edit pointer to the
fifth column of the current line.
</para>
    </section>
    <section>
      <title>Verify On/Off</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>V <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>FUNCTION:</term>
        <listitem>
            <para>Turn verify ON / OFF</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>MODE:</term>
        <listitem>
          <para>Directive to Editor</para>
        </listitem>
      </varlistentry>
   </variablelist>

      <para>
This command is used to turn the verify mode on or off. If the verify
mode is turned on (the default), many edit commands will display their
results which can be annoying and/or time consuming when certain commands
are used repetitively (such as <quote>c</quote>, and <quote>d</quote>). If you turn verify off, it
may be turned on again by specifying a non-zero value for <replaceable>n</replaceable>.
For example:
      <simplelist type="horiz" columns="3">
<member>V</member>
<member>V20</member>
</simplelist>
Either of the two examples above would turn the verify mode on. To turn
the verify mode off use the following command:
<screen>
V0
</screen>
Macros inherit the current verify mode, but if a macro changes the mode
the change will only apply within the macro call.
</para>
    </section>
  </section>
  <section>
    <title>Advanced Commands</title>
    <para>
This section discusses the editor commands that are available for
more sophisticated editing tasks. The advanced commands can be divided
into four general categories:
</para>
    <variablelist>
      <?dbfo list-presentation="blocks"?>
      <varlistentry>
        <term>File Manipulation Commands</term>
        <listitem>
          <para>
These commands allow files to be opened, created; closed, read
from, and written to. The editor can work with several files at the same time.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Buffer Manipulation Commands</term>
        <listitem>
          <para>
These commands let you create multiple edit buffers, switch
between them, and copy lines or blocks of text from buffer to
buffer.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Loops and Conditional commands</term>
        <listitem>
          <para>
These commands allow sequences of edit commands to be executed
repetitively, and to apply various conditional tests. Using these
functions you can create editor <quote>programs</quote>.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Macros</term>
        <listitem>
          <para>
These commands allow sequences of edit commands (including loops
and conditionals) to be stored, edited, saved, loaded and
executed.
</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>File Manipulation Commands</title>
    <section>
      <title>New</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.NEW</para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command is used when the file being edited is too large to fit into
the editor's workspace at one time.
</para>
      <para>
All lines of text before the current edit pointer position are written to
the output file. The editor will then try to read new text lines from
the input file, which are appended to the end of the edit buffer. The
editor attempts to read as many new lines as were written out.; The <quote>NEW</quote>
command always uses the initial input and output files
(i.e., the files specified in the command line used to run the editor).
</para>
      <para>
If you have finished editing the text currently in the edit buffer, you
may <quote>flush</quote> it out and refill the buffer with new text by moving the edit
pointer to the bottom of the edit buffer and then use the <quote>.NEW</quote> command
as follows:
<screen>
E:/.NEW <keycap>RETURN</keycap>
</screen>
If you wish to retain part of the text that is already in the edit
buffer,- move the edit pointer to the first line that you wish to retain,
before using the <quote>.NEW</quote> command.

</para>
    </section>
    <section>
      <title>Open Input File</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.READ <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command is used to open an OS-9 text file for reading, or to close
the file after it is no longer needed. The file opened replaces the
original input file specified on the command line used to call the
editor.
</para>
      <para>
To open a file, <quote><replaceable>str</replaceable></quote> is used to specify the OS-9 file name, for example:
<screen>
E:.READ "myfile" <keycap>RETURN</keycap>
</screen>
To close an input file, the .READ command is used with an empty string as
shown below. Closing a file previously opened using the .READ command
also restores the original input file.
<screen>
E:.READ "" <keycap>RETURN</keycap>
</screen>
When a file is opened it remains attached to the current primary buffer
to allow each buffer to have its own independent input file. These files
may be read by switching to the proper buffer, then using the <quote>R</quote> command
to read from that buffer's input file. When closing a file, you must
select the same primary that the file was opened with.
</para>
    </section>
    <section>
      <title>Create Output File</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.WRITE <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command is used to create a new output file or to close the file
after it is no longer needed. The file opened replaces the original
output file specified on the command line used to call the editor.
</para>
      <para>
To create an output file, <quote><replaceable>str</replaceable></quote> gives the OS-9 file name, for example;
<screen>
E:.WRITE "myfile" <keycap>RETURN</keycap>
</screen>
To close an output file, the .WRITE command is used with an empty string
as shown below. Closing a file previously opened using the .WRITE
command also restores the original output file.
<screen>
E:.READ "" <keycap>RETURN</keycap>
</screen>
When a file is created it remains attached to the current primary buffer
so buffer can have its own independent output file. These files may be
written to by switching to the proper buffer, then using the <quote>W</quote> command
to write to the buffer's output file. When closing a file, you must
select the same primary buffer that the file was opened with.

</para>
    </section>
    <section>
      <title>Read From Input File</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>R <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command is used to read <quote><replaceable>n</replaceable></quote> lines of text from the buffer's input
file. The lines read in are displayed and inserted before the current
edit position. For example:
</para>
      <simplelist type="horiz" columns="3">
<member>R10</member>
<member>R*</member>
</simplelist>
<para>
The first example reads ten lines of text from the input file, and the
second example reads all remaining lines. If there is no more text in a
file, the <quote>*END OF FILE*</quote> warning message will be displayed.

</para>
    </section>
    <section>
      <title>Write To Output File</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>W <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command is used to write up to <quote><replaceable>n</replaceable></quote> lines of text from the buffer-to
its output file. The lines are written starting at the current edit
position. For example:
</para>
      <simplelist type="horiz" columns="3">
<member>W10</member>
<member>W*</member>
</simplelist>
<para>
The first example writes ten lines and the second writes all remaining lines of text.
</para>
    </section>
  </section>
  <section>
    <title>Buffer Manipulation Commands</title>
    <section>
      <title>Display Buffer And Macro Directory</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.DIR</para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command is used to display the directory of the editors buffers and
macros. For example:
<screen>
E:.DIR <keycap>RETURN</keycap>

BUFFERS:
$       0
*       1
       50

MACROS:
  MYMACRO
  INDENT
</screen>
Under the heading BUFFERS is a list of all current edit buffers. The
current primary buffer is marked with an asterisk (Buffer #1 in the
example above). The current secondary buffer is marked with a dollar
sign (Buffer #0 in the example above). All other buffers are listed but
otherwise unmarked (such as Buffer #50 above).
</para>
      <para>
Under the heading MACROS is a the list all current macros. The example
above shows the macros MYMACRO and INDENT.
</para>
    </section>
    <section>
      <title>Change and/or Create Primary Edit Buffer</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>B <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

      <para>
This command is used to make buffer number <quote><replaceable>n</replaceable></quote> the primary edit buffer.
The previous primary buffer becomes the new secondary buffer. If you
specify the number of a buffer that does not already exist, a new buffer
will be created and assigned the buffer number. For example, assume the
current primary buffer is 1, then the following command is given.
      <simplelist type="horiz" columns="3">
<member>B5</member>
</simplelist>
The example above makes buffer 5 the new primary edit buffer, and buffer
1 would become the new secondary buffer.
</para>
    </section>
    <section>
      <title>Move Lines From Primary Buffer</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>P <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>This command is used to move <quote><replaceable>n</replaceable></quote> lines of text from the primary buffer to
the secondary buffer. The lines are removed from the primary edit buffer
starting at its edit position and inserted into-the secondary buffer
(before its edit position. The text moved is displayed. Some examples of
the use of this command are:
</para>
      <simplelist type="horiz" columns="3">
        <member>P</member>
        <member>P5</member>
        <member>P*</member>
      </simplelist>
      <para>
The first example moves one line of text, the second example moves five
lines of text, and the last example moves all lines that are between the
current edit position and end of text.
</para>
      <para>
This command is often used in combination with the <quote>G</quote> command below to
perform block transfers of text within a buffer. The example below
illustrates the block move operation.
</para>
      <orderedlist>
        <listitem>
          <para>
Move edit pointer to first line to be moved.
</para>
          <screen>
E:S/First line/ <keycap>RETURN</keycap>
  First line to be moved
</screen>
        </listitem>
        <listitem>
          <para>
Put lines in secondary buffer (in this case, 2 lines).
</para>
          <screen>
E:P2 <keycap>RETURN</keycap>
</screen>
        </listitem>
        <listitem>
          <para>
Move edit pointer to where text is to be reinserted.
</para>
          <screen>
E:+20 <keycap>RETURN</keycap>
</screen>
        </listitem>
        <listitem>
          <para>
Get lines back from secondary buffer
</para>
          <screen>
E:G2 <keycap>RETURN</keycap>
  First line to be moved
  Second line to be moved
</screen>
        </listitem>
      </orderedlist>
    </section>
    <section>
      <title>Move Lines To Primary Buffer</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>G <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

      <para>
This command is the reverse of the P command. Text lines are taken from
the top (beginning) of the secondary buffer and inserted into the primary
buffer before its current edit position.
</para>
    </section>
  </section>
  <section>
    <title>Looping And Conditionals</title>
    <para>
An important advanced feature of the editor is its ability_for
looping and conditional tests allow sequences of commands to be repeated
a number of times until a certain condition is met. For example, you can
repeat a sequence of commands until a certain string is encountered in
the text.
</para>
    <para>
The looping and conditional features, especially when combined with
the macro functions discussed in the next section, give the editor many
characteristics of a programming language.
</para>
    <section>
      <title>Looping</title>
      <para>
A loop is constructed by enclosing one or more commands in square
brackets. A loop count value (which can be a number or <quote>*</quote>) specifies
how many times the command within the loop are to be repeated. If any of
the commands fails (such as an unsuccessful string search), the loop will
be exited prematurely. For example, the commands in the loop shown below
will be executed 12 times or until the string in the search can't be found.
<screen>
[ S/This line should be removed/ -1 D ] 12
</screen>
If a loop is typed in as a command for immediate execution, it must
fit in one complete line. If a loop is contained within a macro, it can
extend across multiple lines. Loops can be nested within each other.
</para>
    </section>
    <section>
      <title>The Fail Flag</title>
      <para>
When an edit command is not able to complete its operation, the
editor will set an internal flag called the fail flag. For instance if
you tried to read from a file that had no more text in it, the editor
would set the fail flag. The fail flag is used to control loops and
conditional statements.
</para>
      <para>
After the fail flag has been set, the editor skips commands until it
reaches: a) the end of a keyboard command line, or b) the end of the
current loop or c) an IF (<quote>:</quote>) command.
</para>
      <para>
The testing commands described in this section set or clear the fail
flag. The other commands listed below can also set the fail flag upon
condition noted:
</para>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.0in"/>
          <colspec colwidth="5.0in"/>
          <tbody>
            <row>
              <entry>&lt;</entry>
              <entry>Attempt to move the edit pointer before the beginning of the buffer.</entry>
            </row>
            <row>
              <entry>&gt;</entry>
              <entry>Attempt to move the edit pointer past the end of the buffer.</entry>
            </row>
            <row>
              <entry>S</entry>
              <entry>Not finding the search string.</entry>
            </row>
            <row>
              <entry>C</entry>
              <entry>Not finding the search string.</entry>
            </row>
            <row>
              <entry>G</entry>
              <entry>No text left in the secondary buffer.</entry>
            </row>
            <row>
              <entry>R</entry>
              <entry>No text left in the read file.</entry>
            </row>
            <row>
              <entry>P,W</entry>
              <entry>No text left in the primary buffer.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section>
      <title>Conditional Statements</title>
      <para>
Conditional statements can be formed inside loops using the <quote>:</quote>
operator. When the <quote>:</quote> is encountered, all statements that follow until
the end of the current loop or macro are skipped if the fail flag is not
set (e.g., fail flag is cleared).
</para>
      <para>
Below is an example of a command line which deletes all lines of
text that do not begin with <quote>A</quote>:
<screen>
^ [ .NEOB [ .STR"A" + : D ] ]*
</screen>
The <quote>^</quote> moves the edit pointer to the beginning of the buffer. The outer
loop tests for when the end of the buffer is reached and terminates the
loop. The inner loop tests for an <quote>A</quote> at the beginning of the line. If
there is one, the <quote>+</quote> command is executed, otherwise the <quote>D</quote> command is
executed.
</para>
      <para>
Below is another example which searches the current line for <quote>find it</quote>.
If found, the line will be displayed, otherwise the command line
will fail and <quote>* FAIL *</quote> will be printed:
<screen>
[ .EOL V0 -0 V .F : .STR"find it" -0 .S    : [&gt;] ]*
</screen>
In the command line above, the first part is <quote>.EOL V0 -0 V .F</quote>, which
tests if the edit pointer is at the end of the line. If it is, verify
mode is turned off to prevent the <quote>-0</quote> from displaying the line, and then
it is turned back on and the <quote>.F</quote> causes the loop to be terminated. If
the edit pointer is not at the end of the line, the <quote>.STR</quote> command will
see if <quote>find it</quote> is at the current edit position. If it is, the <quote>-0 .S</quote>
commands will be executed to cause the edit pointer to be moved back to
the beginning of the line, the line displayed, and the loop terminated.
Otherwise the <quote>&gt;</quote> command is executed which moves the edit pointer to the
next position in the line. Note that it is enclosed in brackets to
prevent it from failing and terminating the main loop if the end of the
buffer is reached.
</para>
    </section>
  </section>
  <section>
    <title>Testing Commands</title>
    <para>
The commands that follow test for certain conditions, and either set
or clear the fail flag depending on the result of the test.
</para>
    <section>
      <title>Test For End of File</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.EOF</para>
        </listitem>
      </varlistentry>
  </variablelist>

      <para>
This command clears the fail flag if the input file is at end-of file,
otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For Not End of File</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.NEOF</para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command clears the fail flag if the input file is not at end-of
file, otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For End of Buffer</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.EOB</para>
        </listitem>
      </varlistentry>
  </variablelist>

      <para>
This command will clear the fail flag if the edit pointer is at the end
of the buffer, otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For Not End of Buffer</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.NEOB</para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command will clear the fail flag if the edit pointer is not at the
end of the buffer, otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For End of Line</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.EOL</para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command will clear the fail flag if the edit pointer is at the end
of a text line, otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For Not End of Line</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.NEOL</para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command will clear the fail flag if the edit-pointer is not at the
end of the line, otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For Zero</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.ZERO <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command will clear the fail flag if <quote><replaceable>n</replaceable></quote> is equal to zero, otherwise
it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For Star</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.STAR <replaceable>n</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command will clear the fail flag if <quote><replaceable>n</replaceable></quote> is equal to 65535 (the value
of <quote>*</quote>), otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For String Match</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.STR <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>
      <para>
This command will clear the fail flag if the characters at the current
edit position match <quote><replaceable>str</replaceable></quote>, otherwise it will set the fail flag.
</para>
    </section>
    <section>
      <title>Test For String Mismatch</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.NSTR <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command will clear the fail flag if the characters at the current
edit position do not match <quote><replaceable>str</replaceable></quote>, otherwise the fail flag will be set.
</para>
    </section>
    <section>
      <title>Exit And Clear</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.S</para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command is an unconditional exit from the innermost loop or macro;
The fail flag is cleared after the exit.
</para>
    </section>
    <section>
      <title>Exit And Fail</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
          <para>.F</para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command is an unconditional exit from the innermost loop or macro.
The fail flag is set after the exit.
</para>
    </section>
  </section>
  <section>
    <title>Macros</title>
    <para>
Macros are new commands that you may create to perform a specialized
or complex task. For example, there may be a frequently used sequence of
commands that you wish to replace with a single macro. You store the
sequence of commands in a macro, after which they may be executed by
simply typing a period followed by the macro name and optional
parameters.
</para>
    <para>
Macros can be saved and loaded from disk files so you can create a
personalized macro library.
</para>
    <para>
Macros are made up of two main parts, the macro header and the macro
body. The macro header is used to give the macro a name and describe the
type and order of its parameters. The macro body is made up of any
number of ordinary command lines (any edit command may be used in a macro
except the <quote><keycap>SPACE</keycap></quote> and the <quote><keycap>RETURN</keycap></quote> commands).
Also, macros can not create new macros.
</para>
    <para>
To create a macro, you must first open its definition with the
<quote>.MAC</quote> command. After doing so, you may enter the macro's header and
body just as you would enter text into an edit buffer (you may use any of
the edit commands to do so). When you are satisfied with the macro, you
may close its definition with the <quote>Q</quote> command to return you to the normal
edit mode.
</para>
    <section>
      <title>Macro Headers</title>
      <para>
A macro header must be the first line in each macro. It is made up
of a macro name which may be followed by a <quote>variable list</quote> that describes
the macro's parameters if there are any. The macro name consists of any
number of consecutive letters and underline characters. Below are some
example macro names:
</para>
      <simplelist type="vert">
        <member>MACRO</member>
        <member>trim_spaces</member>
        <member>LIST</member>
        <member>EXTRA_LONG_MACRO_NAME</member>
      </simplelist>
      <para>
Although a macro name may be of any length, it is advisable to limit
them to a reasonable length since the name must be spelled exactly the
same way each time that you use it. Upper case and lower case letters
are taken to be equivalent and may be used interchangeably.
</para>
    </section>
    <section>
      <title>Parameters and Variables</title>
      <para>
Like other edit commands, macros may also be given parameters so
that they are able to work with different values. Parameters are
available to the commands that make up the macro. To pass the macro's
parameters to these commands, we need a way to tell each command which of
the macro's parameters it should use. This is what the variable list in
the macro header is for. Each variable in the variable list is used to
represent the value of the macro parameter in its corresponding position.
Then wherever the parameter's value is needed, the corresponding variable
should be used.
</para>
      <para>
There are two types of variables: numeric and string. A numeric
variable is a variable name is preceded by a <quote>#</quote> character. A string
variable is a variable name preceded by a <quote>$</quote> character. Variable names
are just like macro names which are composed of any number of consecutive
letters and underline characters. Some example numeric variables are:
</para>
      <simplelist type="vert">
        <member>#N</member>
        <member>#ABC</member>
        <member>#LONG_NUMBER_VARIABLE</member>
      </simplelist>
      <para>
Some example string variables are:
</para>
      <simplelist type="vert">
        <member>$A</member>
        <member>$B</member>
        <member>$STR</member>
        <member>$STR_A</member>
        <member>$lower_case_variable_name</member>
      </simplelist>
      <para>
An example of an entire edit macro is given below. It will do the
same thing as the <quote>S</quote> command: search for the next <quote><replaceable>n</replaceable></quote> occurrences of a
string. The first line of the macro is the macro header; it declares the
macro's name to be <quote>FIND_LN</quote> and also specifies that the macro needs one
numeric parameter <quote>#N</quote> and one string parameter <quote>$STR</quote>. The entire body
of the macro is the second line. Here, both of the macro's parameters
are passed to the <quote>S</quote> command to do the actual searching:
</para>
      <programlisting>
FIND_LN #N  STR
S #N $STR
</programlisting>
      <para>
Here is how this macro would be called:
<screen>
E:.FIND_LN 15 "string" <keycap>RETURN</keycap>
</screen>
To illustrate the importance of the parameter position in the macro
header, we will reverse their order in the next example to make it
necessary to use the reverse order when executing the macro. Here is the
macro definition:
</para>
      <programlisting>
FIND_LN $STR #N
S #N $STR
</programlisting>
      <para>
We must still specify the parameters for the <quote>S</quote> command in the proper
order since it is only the <quote>FIND_LN</quote> macro that was changed. Below is an
example of how this macro is executed, notice that the order of the
parameters directly correspond to the order of the variables in the
variable list:
</para>
      <screen>
.FIND_LN "string" 15
</screen>
    </section>
    <section>
      <title>Creating and Editing Macros</title>
      <para>
Macros are created and edited using the normal editor command set.
The <quote>.MAC</quote> command is used to create a new macro or open the definition
of an existing one so that it may be edited. To create a <emphasis>new</emphasis> macro, you
use <quote>.MAC</quote> with an empty string, for example:
<screen>
E:.MAC // <keycap>RETURN</keycap>
</screen>
This creates a new macro and puts you into macro definition mode. The
editor responds with the <quote>M:</quote> prompt instead of the normal <quote>E:</quote> edit
prompt when in macro definition mode. If you wish to edit a macro that
already exists, <quote><replaceable>str</replaceable></quote> is used to specify the macro's name. For example:
<screen>
E:.MAC "MYMACRO" <keycap>RETURN</keycap>
</screen>
This opens the existing macro <quote>MYMACRO</quote> for editing. When a macro is
open, you may edit it or enter its definition by using the edit commands
as you would with an ordinary text buffer.
</para>
      <para>
The <quote>Q</quote> command is used to close the definition of a macro and
return to the normal edit mode. For example:
<screen>
M:Q <keycap>RETURN</keycap>
</screen>
This would close the definition of the macro currently open and return
the editor to its normal edit mode. Before the editor will allow you to
close the definition of a macro, the first line of the macro must begin
with a legal macro name that has not already been used for another macro.
</para>
    </section>
  </section>
  <section>
    <title>Macro Commands</title>
    <section>
      <title>Comment</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>! <replaceable>text</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

      <para>
The <quote>!</quote> command may be used to place comments inside of a macro for
documentation. The remainder of the line following the <quote>!</quote> command is
retained but never processed as a command.
</para>
    </section>
    <section>
      <title>Load Macros From File</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.LOAD <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command is used to load macros from an OS-9 file. The file name
pathlist is specified by <quote><replaceable>str</replaceable></quote>. As each macro is loaded, EDIT will make
sure that no other macro already exists with the same name. If one does,
the macro will not be loaded and EDIT will skip to the next macro on the
file. EDIT will display the names of all the macros that it loads. Some
examples of this command are:
<screen>
E:.LOAD "macrofile"<keycap>RETURN</keycap>
E:.LOAD "MYFILE" <keycap>RETURN</keycap>
</screen>

</para>
    </section>
    <section>
      <title>Save Macros</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.SAVE <replaceable><replaceable>str1</replaceable></replaceable> <replaceable>str2</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

  <para>
This command is used to save macros on an OS-9 file. The first string is
used to specify a list of macros that are to be saved; the macro names
are separated by spaces. The second string specifies the pathlist for
the file on which the macros are to be saved. Some typical examples of
the use of this command are:
<screen>
E:.SAVE "MYMACRO"MYFILE" <keycap>RETURN</keycap>
E:.SAVE "MACA MACB MACC"MFILE" <keycap>RETURN</keycap>
</screen>
The first example saves the macro <quote>MYMACRO</quote> on the file <quote>MYFILE</quote>, the
second saves the macros <quote>MACA</quote>, <quote>MACB</quote>, and <quote>MACC</quote> on the file <quote>MFILE</quote>.
When more than one macro is to be saved on a single file, their names
should be separated by spaces.
</para>
    </section>
    <section>
      <title>Delete Macro</title>
    <variablelist spacing="compact">
      <varlistentry>
        <term>SYNTAX:</term>
        <listitem>
            <para>.DEL <replaceable>str</replaceable></para>
        </listitem>
      </varlistentry>
  </variablelist>

      <para>
This command is used to delete (erase) the macro specified by <quote><replaceable>str</replaceable></quote>. For
example to delete a macro called <quote>MYMACRO</quote> use:
<screen>
E:.DEL "MYMACRO" <keycap>RETURN</keycap>
</screen>
</para>
    </section>
  </section>
</chapter>
