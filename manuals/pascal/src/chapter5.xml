<chapter xmlns="http://docbook.org/ns/docbook">
<title>"PASCALE" - The Pascal Linkage Editor</title>

<abstract>
<para>SYNOPSIS: "PascalE" is a linkage editor used to create a
single program consisting of a "mainline" program having EXTERNAL
declarations and one or more separately compiled external native
code procedures. PascalE is only used when separate compilation is
desired or when P-code and native code procedures are mixed in the same
program. PascalE is intended for use by advanced programmers.</para>
</abstract>

<sect1>
<title>An Overview of PASCALE</title>

<para>Whenever a Pascal program contains one or more EXTERNAL routines,
the P-code file for that program must be edited using PascalE after
compilation before it can be executed. PascalE inserts addresses of
external native code routines in the appropriate places in the program
so the external procedures can be called.</para>
<para>PascalE is an interactive program. For each external procedure,
you must supply the file name of the module containing the native code
version of the procedure, the offset from the starting execution address
of the module for the first instruction of the procedure, the type of the
module, and the local and extended stack requirements of the external
procedure- Normally, all this information is built automatically by
PASCALT, in which case the operation of PASCALE is almost trivial. If
the external modules were not created by PascalT (such as when the
external module is hand-written in assembly language), you need to know
how external procedures are handled by OS-9 Pascal so you can properly
interface them.</para>

<para>When PascalN or PascalS begins processing a P-code file, one
of the first actions taken is to check for the existence of external
procedure declarations. When one or more of such declarations are found,
a special table in the P-code file is consulted for more information
about each declaration. First, the interpreter needs to know if the
module containing the native code external procedure is already loaded
into memory. If it is not, it needs to know the path name of the module
so that it can be loaded into memory. After ensuring that all required
modules are in memory, the interpreter needs only to complete its internal
tables for each procedure with its execution address and its local and
extended stack sizes. It may be that all external routines are contained
in a single module, but it is likely that some of the required external
routines are in other modules. As an example, a program which does signal
processing may call a native code procedure to do Fourier analysis on
the data, and also call several routines in a different module to do
digital plotting of the results.</para>
</sect1>

<sect1>
<title>Running PASCALE</title>
<para>To run the PASCALE utility, use the command form:</para>

<screen>
PASCALE &lt;extdeffile :pcodefile
</screen>

<para>"extdeffile" is the name of the file containing the external definition file records to be processed. This file is automatically generated by PascalT using the default file name "PCODEFINFO". If you are attempting to link hand written native code, you can omit the path name and the preceding "&lt;" character if you want to enter the definition file records from the standard input path (usually the terminal). In this case, simply enter one or more "use" records (which are discussed further on) from the terminal to cause the proper external definition files to be processed. If input is from a terminal, remember that "use" records begin with a space character, and that after all definition file records have been entered you need to key in the "end of file" sequence (usually the escape or ESC key which is <keycombo action="simul"><keycap>CLEAR</keycap><keycap>BREAK</keycap></keycombo> on the color computer).</para>

<para>"pcodefile" is the path name of the P-code file to be updated with the external file information. The file name must be immediately preceded by a colon character - no leading space characters or other characters are permitted. There is no default name assumed, so that if you wanted, for instance, to refer to the default P-code file produced by the OS-9 Pascal compiler, you would enter ":PCODEF".</para>

<para>If the ":"character is omitted, or if it is not followed immediately by a path name, the following error message will be given:</para>

<para>
<computeroutput>*ERROR No P-code file name has been found. A P-code file name must be supplied immediately following a ":" on the command line.</computeroutput>
</para>

<para>If the P-code file doesn't exist, or if there is an OS-9 error encountered while trying to open the file, the following error message is given:</para>

<para>
<computeroutput>*ERROR OS-9 error x encountered when trying to open file.</computeroutput>
</para>

<para>where "x" is the OS-9 error number. Refer to the <citetitle pubwork="book">OS-9 Commands Manual</citetitle> for the meaning of the error number. If the P-code file is found to have been altered, which could produce catastrophic results, or if the file is not a P-code file after all, the following error message is given:</para>

<para><computeroutput>*ERROR P-code file has been altered or has invalid format.</computeroutput>
</para>

<para>If there were compile time errors found when the P-code file was produced, the. P-code file is unusable, and the following error message is given:</para>

<para><computeroutput>*ERROR P-code file has x compile time errors, it cannot be processed.</computeroutput>
</para>

<para>"x" is the number of compile time errors which were detected. If the P-code file has no EXTERNAL procedures declared within, the following error: message is given:</para>

<para><computeroutput>*ERROR P-code file has no external routines.</computeroutput>
</para>

<para>If a record is found within the external definition file which has a space character in the first character position, but is not immediately followed by the letters "use", another space character, and then a path name, the following error message is given:</para>

<para><computeroutput>*ERROR Invalid command on line number x at USE file nesting level of y</computeroutput>
</para>

<para>Where "x" is the current line number in the text file which is being processed, and "y" is the use file nesting level as described earlier in this section. If a valid "use" command is encountered, but the referenced file cannot be opened, the following error message is given:</para>

<para><computeroutput>*WARNING OS-9 error x encountered while trying to open USE file y</computeroutput>
</para>

<para>Where "x" is the OS-9 error number, and "y" is the path name of the file from the "use" record. If a record in the external definition file is not a valid comment, use, or definition record, the following error message is given:</para>

<para><computeroutput>*ERROR Invalid EXTERNAL definition format on line number x at USE file nesting level of y</computeroutput>
</para>

<para>Where "x" is the current line number in the text file which is being processed, and "y" is the use file nesting level as described earlier in this section. The previous error message is also given if any field of a definition record is not in a valid format - such as a number being out of range, or a name being too long or being composed of the wrong type of characters.</para>

<para>After PASCALE has completely processed the external definition file,
it checks to see if all declared external procedures have been mapped. If
not, a list is produced of all of the procedure names, procedure numbers,
and module types which were not processed during this execution. It is
possible that you processed these procedures during a previous execution
or that you will process these procedures in a future execution. You must,
however, cause every external procedure to be mapped by PASCALE before
you will be allowed to run or even translate the P-code file.</para>

<para>Finally, if you are going to run the P-code file via one of the
OS-9 Pascal interpreters, you can use PASCALE between executions to remap
the external procedures. If you translate a complete P-code file into
a native code program, however, the mapping that exists at the time of
the translation is permanently encoded into the native code program -
to change that mapping you must re-execute PASCALE for the P-code file,
and then retranslate the P-code file. Partial translations of a P-code
file are not permanently affected in this way.</para>
</sect1>

<sect1>
<title>The External Definition File</title>

<para>If you want to link hand written external assembly language procedures to a P-code program, you must understand the format of "external definition files". There are three types of records that can exist in the external definition file.</para>
<simplesect>
<title>Comment Records</title>
<para>Comment records start with an "*" character in the first character position followed by any other printable characters that you desire. The line is ignored by PASCALE and is allowed simply to give you a way to put descriptive information into the file. You should always insert comment records to name the original source program from which the external definition records were derived, the version of that program (if such information is kept), and a time and date stamp of when either the external definition file was created or when the original source program was compiled. If you intend that others might use your external routines, you should also include some sort of documentation of the use of the routines - at least a simple statement naming each procedure and its use.</para>
</simplesect>
<simplesect>
<title>Use Records</title>

<para>The second type of record is the "use" record. It consists of a single space character followed by the letters "USE", followed by another space character, followed by a path name; upper and lower case letters are considered to be equivalent. The use of "use" records allows you to construct nested or subordinate structures of external definition files. The path name given refers, of course, to the name of another text file containing further external definition records. This other file could even contain its own "use" records. The level of nesting is restricted only by the amount of extended stack space available when PASCALE is run. As each "use" record is encountered, processing of the current external definition file is temporarily suspended while the referenced file is processed.</para>
<para>When PASCALE first begins execution, the "USE file nesting level" is zero. When the first "use" record is found, the nesting level goes up to 1. If the referenced file also has a "use" record, the nesting level will go up to 2 while the newly referenced file is being processed. Naturally, the nesting level goes back down by one after each referenced file is processed. The nesting level is important only for interpreting any error messages which might be produced by PASCALE. After the last record in a "use" file is processed, processing continues with the record after the "use" record which referenced that last file.</para>
</simplesect>

<simplesect>
<title>Definition Records</title>
<para>The third type of record is the "definition" record. Each record has exactly 6 fields of information, and can be up to 127 characters in length. The first field is the name of the procedure being described as it would be named by a source program. The name must be between 1 and 8 characters in length. The first character must be a letter, but succeeding characters can be letter, digit, or underscore characters. Immediately after the procedure name there must be a comma, and after that a module name. The module name can be up to 116 characters in length and gives the path name of the module containing the native code version of the defined procedure. Normally, the module name field contains a fully qualified path name so that any programs which use the external procedure can be run regardless of any setting of data and execution directories. The module name can be any valid OS-9 path name.</para>
<para>When PascalN or PascalS processes an external procedure table entry, it first scans the module name starting at the end and working toward the beginning until either the beginning of the module name is found, or until a slash character is found. The name retrieved is used for an attempted "link" operation, and, if the link fails, the whole module name is used for an attempted "load" operation. Refer to the <citetitle pubwork="book">OS-9 Technical Information</citetitle> manual for a description of link and load operations. The link and load is also qualified by a "module type" field which is described next.</para>
<para>The module name must be immediately followed by a comma, and then
a module type. A module type is a 1 to 3 digit number that must be in
the range from 0 through 255. External procedure modules produced by
PascalT will always have a type of 33 which indicates a native code
subroutine module. The module type is used to qualify the link or load
operation on the module. Following the module type there must be a comma,
and then an offset number. The number must be in the range of 0 through
32767, and when added to the execution address of the linked or loaded
module gives the address of the first instruction to be executed for the
procedure. If there is more than one procedure in a module, the normal
convention is to place a three byte "long branch" instruction for each
procedure as the first executable code for the module. Thus the first
procedure in the module would have an offset of 0, the second an offset
of 3, and so forth.</para>
<para>Following the offset field is a comma, a local stack size number,
another comma, and an extended stack size number. Both of these numbers
must be in the range of 0 through 32767 and must conform to the true
requirements of the procedure as described in various chapters of this
manual. To recap, a "definition" record looks like:</para>

<para><literallayout>proc-name,module-name,type,offset,local-size,extended-size</literallayout></para>

<para>When PASCALE begins execution, one of the first things that it does
is to make a table of all of the procedure names which were declared
as EXTERNAL within the source program. As the external definition
file is processed, the first external definition record that matches
each procedure name in the table is used, all duplicate matches then
being ignored. The implication is as follows. A particular program may
have, say, 17 procedures declared as external. They are to be mapped
to three different modules. One external procedure, however, has the
name of "CLEARSCR" which is the name of a procedure in two of the three
modules. It's quite possible that only one of the modules has the correct
CLEARSCR procedure which is needed in this instance, the other module's
CLEARSCR might perform some totally undesirable action - it just so
happens that both modules just ended up having a procedure with the same
name. To make sure that PASCALE maps your external CLEARSCR references to
the right module, make sure that the correct external definition record
is processed first. That way the second, or any subsequent CLEARSCR
definition records will be ignored. You could, of course, create a text
file containing only the exact required definition records, but it is more
usual to have a single definition file for each module and to simply use
"use" records to cause them to be processed in the correct order.</para>

<para>A problem that is more or less the opposite of that just described
is also possible. You may want to reference both CLEARSCR procedures in
your source program. Clearly you cannot do so by declaring that both
procedures are external with the same name. The solution, however,
is easy. In the source program, declare two different procedures as
external with different names. You can still call one CLEARSCR if you
wish, or maybe you can call one CLEARSC1 and the other CLEARSC2. Now
you just need to create an external definition file for the module which
contains the procedure referenced as say, CLEARSC1. The easiest way to do
this is to make a copy of the original module's external definition file,
and use the OS-9 text editor program to change the name of the procedure
from CLEARSCR to CLEARSC1. Similarly, create an external definition file
for the other module and change the name on the appropriate definition
record from CLEARSCR to, say, CLEARSC2. Now use these two new external
definition files when you run PASCALE against the P-code file for your
source program.</para>

<para>There is one thing that you must be very careful about when using
external procedures. There is no way to ensure that the calling code in
the source program correctly matches the way that the external procedure
needs to be called. For example, an external procedure may be a Pascal
function that returns a real number and takes an integer and a character
array as an argument. Your source program, however, could declare the
external procedure to be a Pascal procedure which takes 4 real numbers
and 5 integers as arguments. OS-9 Pascal has no way to verify that any
program is correctly referencing an external procedure. The program
will compile correctly and PASCALE will correctly map the actual call
of the external procedure to the right native code instructions. When
the program actually executes, however, any such mismatched reference
is likely to destroy the integrity of the running system, quite likely
with catastrophic results! A word of advice then - make sure your source
program calls really match up with what the external routine expects. If
the external module was produced by PascalT, then as long as you refer to
that module only from the source program which was used to create that
module, and as long as you don't change any external procedure's type
(i.e. Pascal function or procedure) or its parameter list, then you need
not worry.</para>
</simplesect>
</sect1>
</chapter>
